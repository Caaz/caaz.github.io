<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Daniel / Caaz]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://caaz.github.io/</link><image><url>https://caaz.github.io/lib/media/favicon.svg</url><title>Daniel / Caaz</title><link>https://caaz.github.io/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 04 Dec 2024 06:37:07 GMT</lastBuildDate><atom:link href="https://caaz.github.io/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 04 Dec 2024 06:37:07 GMT</pubDate><copyright><![CDATA[Daniel Cavazos]]></copyright><ttl>60</ttl><dc:creator>Daniel Cavazos</dc:creator><item><title><![CDATA[Return Early]]></title><description><![CDATA[ 
 <br>Godot doesn't have traditional error handling, so we should use <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Defensive_programming" rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Defensive_programming" target="_blank">defensive programming</a> practices to ensure our games don't explode on users.<br><br>
If it can't be done, do nothing.
<br>One of the easiest ways to apply defensive programming in godot is to <a data-tooltip-position="top" aria-label="https://medium.com/swlh/return-early-pattern-3d18a41bba8" rel="noopener nofollow" class="external-link" href="https://medium.com/swlh/return-early-pattern-3d18a41bba8" target="_blank">return early</a> on invalid states. The basic idea is that the reader of our code mostly cares about the "happy path". This breaks most functions down into two parts: "Check invalid states", "Do what the function is named for"<br>For example, let's take a look at this load_level function. <br>func load_level(index:int) -&gt; void:
	# Check invalid sates
	if levels.size() &lt; index:
		printerr("Invalid level index: {0}".format(index))
		return
		
	if not is_instance_valid(game_node):
		return
	
	# Do the thing
	for child in game_node.get_children():
		child.queue_free()
	
	var level = levels[index].instantiate()
	game_node.add_child(level)
	hide()
<br>It needs to grab a scene from a levels array, instantiate it, and add it as a child to another node. This means we need to check two things:<br>
<br>Is the level index we're trying to add even valid?
<br>Is the node we intend on placing our level a valid node?
<br>If those two succeed, we know we can go on with our process and we're reasonably certain that the function should succeed. If either fail, the function simply does nothing. If we wanted, in the future we could check that if you're loading an already loaded level, it'd also do nothing. This would make the method idempotent. <br><br><br>Returning early really only works for void functions, as functions that return a typed value shouldn't just return void all of a sudden. If we expect an integer, it should return an integer. <br>In Godot, there are functions that explicitly return a value, and error when they cannot. For example, raycasts:<br>if raycast.is_colliding():
	var point = raycast.get_collision_point()
<br>if you were to call get_collision_point without is_colliding == true, then it'd raise an error, this leaves it up to the implementer to only call the method when it can be called.]]></description><link>https://caaz.github.io/godot-thoughts/error-handling.html</link><guid isPermaLink="false">Godot Thoughts/Error Handling.md</guid><dc:creator><![CDATA[Daniel Cavazos]]></dc:creator><pubDate>Wed, 04 Dec 2024 06:03:36 GMT</pubDate></item><item><title><![CDATA[Node and Scene References]]></title><description><![CDATA[ 
 <br>Like all programming problems, referencing a node or scene in a Godot script can be done in many ways. I've found that some of these ways can raise issues during development that can cause problems, and should probably be avoided because of it.<br># via find_child
@onready var some_node = find_child("SomeNode")
# via $Name
@onready var some_node = $SomeNode
# via unique name
@onready var some_node = %SomeNode
# via export
@export var some_node:Node
<br>The first two suffer from an annoying issue, if we happen to restructure the scene's tree, and move SomeNode to a child of a different node, the script breaks, and we have to go in and modify the script to resolve it.<br>The third option is safe from that problem of course, but it runs into a different issue: If you happen to change that node's name, it once again breaks our script causing us to refactor again.<br>The fourth however, an exported variable, I believe is the best solution, it's immune from both of the previous issues, as godot will track when the name or location of the node changes. Additionally, it forces us to properly type hint the node.<br>Scene references have less options for referencing them, but again, I'd avoid hard-coding the path for scenes in a script, as again, moving that file around will break that script. An exported variable instead work well to avoid that.<br>@export var some_scene:PackedScene
<br><br><br>Circular Dependencies can happen with the exported variable approach for scenes specifically. If for example, you have scene_a with an exported variable to scene_b, then have scene_b with an exported variable to scene_a, neither scene will be loadable by the Godot editor.<br>This issue is difficult to notice, as you can set it up in the editor, and while the project is in memory, it's fine. The error only arises when loading the scene into memory. Regularly reloading the project on git merges is a good practice to avoid one of these slipping by.<br>In these scenarios, it might actually be easier to hard-code the scene locations, perhaps in a global autoload script, as at least then if it breaks a script, it'll only break one script.]]></description><link>https://caaz.github.io/godot-thoughts/node-and-scene-references.html</link><guid isPermaLink="false">Godot Thoughts/Node and Scene References.md</guid><dc:creator><![CDATA[Daniel Cavazos]]></dc:creator><pubDate>Wed, 04 Dec 2024 06:34:56 GMT</pubDate></item><item><title><![CDATA[Project Structure]]></title><description><![CDATA[ 
 <br>Generally, the project structure I've seen most is as follows:<br>addons
	(third party plugins and assets)
assets
	art
		sprites
		tiles
		backgrounds
		ui
		vfx
	audio
		music
		sfx
resources
scenes
	(.tscn files)
scripts
	(.gd files)
shaders
<br>What winds up happening is the scripts wind up in the scenes folder and we wind up refactoring eventually which can get messy.<br>
I suggest a scene oriented approach instead:<br>addons
	(third party stuff)
art
	sprites
	tiles
	backgrounds
	ui
	vfx
audio
	music
	sfx
resources
scenes
	(example_scene_folder)
		(example.tscn)
		(example.gd)
scripts
	(global_script.gd)
shaders
<br>The goal here is to take advantage of godot's default script placement (in the folder of the screen it's being instantiated in), so that its default will place it with the scene it's related to. Additionally, this'll mean scenes with a lot of scripts specific to it will be placed in its scene folder, which will contain its messiness.<br>Another benefit, is it'll be very clear which scripts are actually in use and not just leftover from some deleted scene, as if we delete a scene, we'd delete its folder, and all scripts related to it.<br>Additionally, this makes art and audio top level, there's not a massive benefit to stuffing them into assets, they deserve to be first class citizens!<br>The scripts folder that does exist here will be specifically for global, autoload singleton scripts only.]]></description><link>https://caaz.github.io/godot-thoughts/project-structure.html</link><guid isPermaLink="false">Godot Thoughts/Project Structure.md</guid><dc:creator><![CDATA[Daniel Cavazos]]></dc:creator><pubDate>Wed, 04 Dec 2024 06:05:10 GMT</pubDate></item><item><title><![CDATA[Resolving Conflicts]]></title><description><![CDATA[ 
 <br>When using git, Godot scenes (.tscn) files tend to conflict very easily, any new node or resource added to the scene will modify the first line of the scene file:<br>[gd_scene load_steps=5 format=3 uid="uid://bdldxaka32a6w"]
<br>Typically the difference is load_steps, looking into this, it's simply a counter Godot uses to render a loading screen. those steps is the count of resources it needs to load into memory. It appears that Godot will recalculate this value on saving the scene, so whichever half of the conflict is chosen doesn't seem to matter.<br>External Resource conflicts are the more messy problem. External resources are defined in scenes like so:<br>[ext_resource type="Script" path="res://scripts/main_menu.gd" id="1_427ti"]
<br>Each external resource has a path and an id, the id is used to reference that resource throughout the scene, like so:<br>script = ExtResource("1_427ti")
<br>In the event that Godot returns a "missing resource" error and the resource is defined in the scene, it's likely that we've got a circular dependency. More info in <a data-href="Node and Scene References#Circular Dependencies" href="https://caaz.github.io/godot-thoughts/node-and-scene-references.html#Circular_Dependencies" class="internal-link" target="_self" rel="noopener nofollow">Node and Scene References &gt; Circular Dependencies</a>]]></description><link>https://caaz.github.io/godot-thoughts/resolving-conflicts.html</link><guid isPermaLink="false">Godot Thoughts/Resolving Conflicts.md</guid><dc:creator><![CDATA[Daniel Cavazos]]></dc:creator><pubDate>Wed, 04 Dec 2024 06:36:52 GMT</pubDate></item><item><title><![CDATA[Contact Me]]></title><description><![CDATA[ 
 <br>Feel free to reach out to me for literally any topic, I'm always down to chat and meet interesting people. <br>
<br><a data-tooltip-position="top" aria-label="https://caaz.me" rel="noopener nofollow" class="external-link" href="https://caaz.me" target="_blank">Website</a>

<br>My personal website, may or may not be up, depending on how much money I have to blow on a database populated exclusively by spam bots.


<br><a data-tooltip-position="top" aria-label="https://bsky.app/profile/caaz.me" rel="noopener nofollow" class="external-link" href="https://bsky.app/profile/caaz.me" target="_blank">Bluesky @caaz.me</a>

<br>I'll be most active here, posting in-progress projects, and asking the gamedev community their thoughts.


<br><a data-tooltip-position="top" aria-label="https://x.com/DCaazy" rel="noopener nofollow" class="external-link" href="https://x.com/DCaazy" target="_blank">Twitter @DCaazy</a>

<br>Given Twitter's enshittening, I likely won't be active here.


<br><a data-tooltip-position="top" aria-label="https://www.tumblr.com/8bit-caaz" rel="noopener nofollow" class="external-link" href="https://www.tumblr.com/8bit-caaz" target="_blank">Tumblr @8bit-caaz</a>

<br>Mostly abandoned, you can find many of my older pico-8 projects here


]]></description><link>https://caaz.github.io/contact-me.html</link><guid isPermaLink="false">Contact Me.md</guid><dc:creator><![CDATA[Daniel Cavazos]]></dc:creator><pubDate>Wed, 04 Dec 2024 05:53:29 GMT</pubDate></item><item><title><![CDATA[Index]]></title><description><![CDATA[ 
 <br>Hi! My name is Daniel, but I usually go by Caaz. Welcome to my github.io. I plan on treating this as a bit of a personal blog, where I'll rant into the void, and those rantings may or may not get linked to someone at some point.]]></description><link>https://caaz.github.io/index.html</link><guid isPermaLink="false">Index.md</guid><dc:creator><![CDATA[Daniel Cavazos]]></dc:creator><pubDate>Wed, 04 Dec 2024 06:01:16 GMT</pubDate></item></channel></rss>